<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sunburst Editor Pro v6.3 (Crash Fix)</title>
    <style>
        :root {
            --primary: #4361ee;
            --primary-hover: #3a0ca3;
            --bg: #f4f6f8;
            --border: #e0e0e0;
            --header-bg: #f8f9fa;
            --sidebar-bg: #ffffff;
            --input-bg: #ffffff;
            --text-main: #212529;
            --text-muted: #6c757d;
            --danger: #ef233c;
        }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            color: var(--text-main);
            background: var(--bg);
        }

        /* --- SIDEBAR STRUCTURE --- */
        #sidebar {
            width: 460px;
            min-width: 440px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.04);
            z-index: 10;
            height: 100vh;
        }

        /* --- TABS --- */
        .tabs { 
            display: flex; 
            background: #fff; 
            border-bottom: 1px solid var(--border); 
            padding: 0; 
            flex-shrink: 0;
        }
        .tab-btn {
            flex: 1; padding: 18px 0; border: none; background: transparent; cursor: pointer;
            font-weight: 600; color: var(--text-muted); border-bottom: 3px solid transparent; 
            font-size: 13px; transition: all 0.2s ease; letter-spacing: 0.3px; text-transform: uppercase;
        }
        .tab-btn:hover { color: var(--primary); background: #f8f9fa; }
        .tab-btn.active { color: var(--primary); border-bottom: 3px solid var(--primary); background: rgba(67, 97, 238, 0.04); }
        
        #btn-json { display: none; }

        /* FIXED TAB CONTENT SCROLLING */
        .tab-content { 
            display: none; 
            flex-direction: column; 
            flex-grow: 1; 
            overflow-y: auto; 
            position: relative; 
            background: #fff;
            padding-bottom: 20px;
        }
        .tab-content.active { display: flex !important; }

        /* --- SIDEBAR BOTTOM FOOTER --- */
        #sidebar-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            background: white;
            flex-shrink: 0;
            z-index: 20;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.03);
        }
        .update-btn-main {
            width: 100%; padding: 14px; background: var(--primary); color: white; border: none;
            border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 14px; letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3); transition: transform 0.1s, box-shadow 0.1s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .update-btn-main:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 6px 16px rgba(67, 97, 238, 0.4); }
        .update-btn-main:active { transform: translateY(0); }

        /* --- GRID STYLES --- */
        #tab-grid { padding: 0; background: white; height: 100%; }
        
        .grid-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 90px 60px 35px;
            background: #f1f3f5; border-bottom: 1px solid #dee2e6;
            font-size: 11px; font-weight: 700; color: #495057; text-transform: uppercase;
            letter-spacing: 0.5px;
            position: sticky; top: 0; z-index: 5;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .grid-header span { padding: 12px 8px; border-right: 1px solid #e9ecef; text-align: left; }
        .grid-header span:last-child { border-right: none; }

        #rows-container { flex-grow: 1; }

        .data-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 90px 60px 35px;
            border-bottom: 1px solid #f1f3f5;
            transition: background 0.15s;
        }
        .data-row:hover { background-color: #f8f9fa; }
        .data-row:hover .del-cell { opacity: 1; color: #adb5bd; }

        .data-row input[type="text"].lvl-input {
            width: 100%; border: none; background: transparent; padding: 12px 8px;
            font-size: 12px; outline: none; border-right: 1px solid #f1f3f5; 
            box-sizing: border-box; color: #333; transition: all 0.2s; border-radius: 0;
        }
        .data-row input.val-input { 
            width: 100%; border: none; background: transparent; padding: 12px 8px; 
            text-align: right; font-family: 'Consolas', monospace; color: var(--primary); 
            font-weight: 600; font-size: 12px; border-right: 1px solid #f1f3f5; 
            outline: none; transition: all 0.2s; border-radius: 0;
        }
        .data-row input:focus { background: white; box-shadow: inset 0 -2px 0 var(--primary); z-index: 2; }

        .color-wrapper { display: flex; align-items: center; border-right: 1px solid #f1f3f5; padding: 4px 6px; background: transparent; }
        input[type="color"] { border: none; width: 20px; height: 20px; cursor: pointer; background: none; padding: 0; border-radius: 4px; overflow: hidden; margin-right: 6px; }
        input.hex-input { width: 100%; border: none; font-family: 'Consolas', monospace; font-size: 10px; color: #666; text-transform: uppercase; outline: none; background: transparent; }

        .del-cell { display: flex; align-items: center; justify-content: center; cursor: pointer; color: #e9ecef; font-size: 18px; transition: 0.2s; opacity: 0; }
        .del-cell:hover { color: var(--danger) !important; background: #fff5f5; }

        /* Grid Controls Area */
        .grid-controls { 
            padding: 20px; background: white; border-top: 1px solid var(--border); 
            display: flex; flex-direction: column; gap: 15px; 
        }
        .btn-add {
            background: #eef2ff; color: var(--primary); border: 1px solid transparent;
            padding: 12px; border-radius: 8px; cursor: pointer; width: 100%; 
            font-weight: 700; font-size: 13px; transition: 0.2s; display: flex; 
            align-items: center; justify-content: center; gap: 8px;
        }
        .btn-add:hover { background: #e0e7ff; border-color: #c7d2fe; transform: translateY(-1px); }

        /* Import Section */
        .import-section { border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; background: #fff; transition: box-shadow 0.2s; }
        .import-section:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .import-header { padding: 12px 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-weight: 700; color: #555; user-select: none; transition: all 0.2s; }
        .import-header:hover { background: #fff; color: var(--primary); }
        .import-body { padding: 15px; display: none; border-top: 1px solid #e0e0e0; background: #fcfcfc; }
        .import-body.open { display: block; }
        .import-body textarea { width: 100%; min-height: 100px; border: 1px solid #ced4da; padding: 12px; font-family: 'Consolas', monospace; font-size: 11px; margin-bottom: 12px; border-radius: 6px; background: #fff; color: #333; line-height: 1.5; box-sizing: border-box; }
        .import-body textarea:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1); outline: none; }
        .import-help { font-size: 11px; color: #666; margin-bottom: 10px; background: #e3f2fd; padding: 8px 12px; border-radius: 4px; border-left: 3px solid #2196f3; }
        .btn-parse { width: 100%; padding: 10px; background: #495057; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px; }
        .btn-parse:hover { background: #343a40; }

        /* --- SETTINGS TAB STYLES --- */
        #tab-settings { padding: 25px 20px; gap: 20px; background: #f8f9fa; }
        #tab-json { padding: 20px; }

        .settings-card { background: white; border-radius: 12px; border: 1px solid #e9ecef; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.02); }
        .settings-card h3 { margin: 0 0 18px 0; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--primary); border-bottom: 1px solid #f1f3f5; padding-bottom: 10px; font-weight: 800; }
        .control-row { margin-bottom: 15px; }
        .control-label { display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-weight: 600; color: #343a40; margin-bottom: 8px; }
        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        .settings-card input[type="text"], .settings-card input[type="number"], .settings-card select { width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 13px; color: #495057; background: #fff; box-sizing: border-box; transition: all 0.2s; }
        .settings-card input:focus, .settings-card select:focus { border-color: var(--primary); outline: none; box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.15); }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 8px 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #e9ecef; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { height: 16px; width: 16px; border-radius: 50%; background: var(--primary); cursor: pointer; -webkit-appearance: none; margin-top: -5px; box-shadow: 0 2px 4px rgba(0,0,0,0.15); transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.15); }
        .range-val { font-size: 11px; color: var(--primary); font-weight: 700; background: #eef2ff; padding: 2px 8px; border-radius: 10px; }

        .toggle-wrapper { display: flex; align-items: center; gap: 10px; background: #f8f9fa; padding: 12px; border-radius: 8px; border: 1px solid #e9ecef; cursor: pointer; }
        .toggle-wrapper input[type="checkbox"] { accent-color: var(--primary); width: 18px; height: 18px; cursor: pointer; }
        .color-picker-group { display: flex; align-items: center; gap: 8px; }
        .color-btn { width: 36px; height: 36px; padding: 0; border: 1px solid #ced4da; border-radius: 8px; cursor: pointer; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .color-btn input { width: 150%; height: 150%; margin: -25%; cursor: pointer; }
        
        .sub-panel { background: #fcfcfc; border: 1px dashed #ddd; border-radius: 6px; padding: 12px; margin-top: 10px; }
        .sub-panel-title { font-size: 11px; font-weight: 700; color: #999; margin-bottom: 8px; display: block; }

        /* --- MAIN VIEW & MENU --- */
        #main {
            flex-grow: 1; background: var(--bg); position: relative;
            background-image: radial-gradient(#d1d5db 1.5px, transparent 1.5px); background-size: 24px 24px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }
        
        /* MENU BUTTON CONTAINER */
        #menu-container {
            position: absolute; top: 20px; right: 20px; z-index: 100;
        }

        #menu-btn {
            background: white; border: 1px solid #ced4da; color: #495057;
            width: 44px; height: 44px; border-radius: 12px;
            font-size: 20px; cursor: pointer; transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            display: flex; align-items: center; justify-content: center;
        }
        #menu-btn:hover { background: #f8f9fa; transform: scale(1.05); color: var(--primary); }
        
        /* DROPDOWN MENU */
        #main-menu {
            display: none; position: absolute; right: 0; top: 55px;
            background-color: white; min-width: 200px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-radius: 12px; border: 1px solid #e9ecef;
            overflow: hidden; z-index: 101; padding: 6px 0;
            animation: fadeIn 0.15s ease-out;
        }
        #main-menu.show { display: block; }

        .menu-item {
            padding: 12px 20px; text-decoration: none; display: flex; align-items: center; gap: 12px;
            color: #495057; font-size: 13px; font-weight: 600; cursor: pointer; transition: 0.1s;
        }
        .menu-item:hover { background-color: #f1f3f5; color: var(--primary); }
        .menu-separator { height: 1px; background: #e9ecef; margin: 6px 0; }
        .menu-item.danger { color: #e03131; }
        .menu-item.danger:hover { background-color: #fff5f5; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }

        #chart { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; padding: 40px; box-sizing: border-box; }
        #chart svg {
            max-width: 100%; max-height: 100%; width: auto; height: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.12); background: white; display: block; border-radius: 16px;
        }
        
        .pointer-line { 
            fill: none; stroke-linecap: round; cursor: crosshair; 
        }
        /* Increased stroke width for easier clicking on invisible hit area */
        .pointer-hit-area {
            fill: none; stroke: transparent; stroke-width: 15px; cursor: crosshair;
        }
        
        text.draggable { cursor: move; }
        text.draggable:hover { font-weight: 900; }
        
        /* HOVER REVEAL MAGIC */
        .control-handle { 
            cursor: move; stroke: var(--primary); stroke-width: 1px; fill: #4361ee; 
            transition: opacity 0.2s, r 0.1s; 
            opacity: 0; /* Invisible by default */
        }
        
        /* Show handle when group is hovered */
        .line-wrapper:hover .control-handle {
            opacity: 1;
        }
        
        /* Keep handle visible while dragging even if mouse slips off */
        .control-handle.dragging {
            opacity: 1 !important;
        }

        .control-handle:hover { r: 6px; fill: #3a0ca3; stroke: white; stroke-width: 2px; opacity: 1; }

        .tooltip {
            position: absolute; background: rgba(33, 37, 41, 0.95); color: #fff; padding: 10px 14px;
            border-radius: 6px; font-size: 13px; pointer-events: none; opacity: 0;
            transition: opacity 0.15s; margin-top: -10px; transform: translate(-50%, -100%); z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-family: 'Segoe UI', sans-serif;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

<div id="sidebar">
    <div class="tabs">
        <button class="tab-btn active" id="btn-grid" onclick="switchTab('grid')">Data Editor</button>
        <button class="tab-btn" id="btn-settings" onclick="switchTab('settings')">Settings</button>
        <button class="tab-btn" id="btn-json" onclick="switchTab('json')">JSON Source</button>
    </div>

    <div id="tab-grid" class="tab-content active">
        <div class="grid-header">
            <span>Level 1</span><span>Level 2</span><span>Level 3</span><span>Level 4</span><span title="Hex Code">Color</span><span style="text-align: right;">Value</span><span></span>
        </div>
        <div id="rows-container"></div>
        <div class="grid-controls">
            <button class="btn-add" onclick="addGridRow()">
                <span style="font-size:18px; line-height:1;">+</span> Add New Row
            </button>
            
            <div class="import-section">
                <div class="import-header" onclick="toggleImport()">
                    <span>üìÇ Bulk Import (Excel / CSV)</span>
                    <span id="import-arrow">‚ñº</span>
                </div>
                <div class="import-body" id="import-body">
                    <div class="import-help"><strong>Format:</strong> Level1, Level2, Level3, Level4, Value (Tab or Comma separated)</div>
                    <textarea id="csvInput" placeholder="Region	Country	City		100&#10;Marketing	Social	Facebook		500"></textarea>
                    <button class="btn-parse" onclick="parseCSV()">Parse & Overwrite Grid</button>
                </div>
            </div>
        </div>
    </div>

    <div id="tab-json" class="tab-content"><textarea id="jsonInput"></textarea></div>

    <div id="tab-settings" class="tab-content">
        <div class="settings-card">
            <h3>Canvas Dimensions</h3>
            <div class="control-row">
                <label class="control-label">Chart Title</label>
                <input type="text" id="chartTitle" placeholder="My Sunburst Chart" oninput="renderCurrent()">
            </div>
            <div class="control-grid">
                <div><label class="control-label">Width (px)</label><input type="number" id="chartWidth" value="1000" onchange="renderCurrent()"></div>
                <div><label class="control-label">Height (px)</label><input type="number" id="chartHeight" value="1000" onchange="renderCurrent()"></div>
            </div>
        </div>

        <div class="settings-card">
            <h3>Appearance</h3>
            <div class="control-row">
                <label class="control-label">Color Theme</label>
                <select id="colorTheme" onchange="applyThemeReset()">
                    <option value="vivid" selected>‚ú® Vivid (Modern)</option>
                    <option value="ocean">Ocean</option>
                    <option value="sunset">Sunset</option>
                    <option value="forest">Forest</option>
                    <option value="corporate">Corporate</option>
                    <option value="neon">Neon</option>
                    <option value="berry">Berry</option>
                    <option value="schemeCategory10">Standard 10</option>
                </select>
            </div>
            <div class="control-grid">
                <div><label class="control-label">Visual Style</label><select id="visualStyle" onchange="renderCurrent()"><option value="flat" selected>Flat</option><option value="bevel">3D Bevel</option><option value="shadow">Drop Shadow</option><option value="glow">Outer Glow</option></select></div>
                <div><label class="control-label">Texture</label><select id="textureOverlay" onchange="renderCurrent()"><option value="none" selected>None</option><option value="lines">Stripes</option><option value="dots">Dots</option><option value="grid">Grid</option></select></div>
            </div>
            <div class="sub-panel">
                <span class="sub-panel-title">Opacity</span>
                <div class="control-grid">
                    <div><label class="control-label" style="font-weight:normal;">L1</label><input type="range" id="opL1" min="0.1" max="1" step="0.1" value="1" oninput="renderCurrent()"></div>
                    <div><label class="control-label" style="font-weight:normal;">L2</label><input type="range" id="opL2" min="0.1" max="1" step="0.1" value="1" oninput="renderCurrent()"></div>
                    <div><label class="control-label" style="font-weight:normal;">L3</label><input type="range" id="opL3" min="0.1" max="1" step="0.1" value="1" oninput="renderCurrent()"></div>
                    <div><label class="control-label" style="font-weight:normal;">L4</label><input type="range" id="opL4" min="0.1" max="1" step="0.1" value="1" oninput="renderCurrent()"></div>
                </div>
            </div>
            <div class="control-row" style="margin-top: 15px;">
                <label class="control-label">Background</label>
                <div class="toggle-wrapper">
                    <input type="checkbox" id="bgTransparent" checked onchange="toggleBgColor()"> <span style="font-size:12px; flex:1;">Transparent</span>
                    <div class="color-btn"><input type="color" id="bgColor" value="#ffffff" disabled oninput="renderCurrent()"></div>
                </div>
            </div>
        </div>

        <div class="settings-card" style="border-left: 3px solid var(--primary);">
            <h3>Shape & Borders</h3>
            <div class="control-grid">
                <div><label class="control-label">Stroke</label><div class="color-picker-group"><div class="color-btn" style="width:100%"><input type="color" id="strokeColor" value="#ffffff" oninput="renderCurrent()"></div></div></div>
                <div><label class="control-label">Width <span id="val-sw" class="range-val">2px</span></label><input type="range" id="strokeWidth" min="0" max="10" value="2" step="0.5" oninput="updateRangeLabel('sw', this.value, 'px'); renderCurrent()"></div>
            </div>
            <div class="control-row" style="margin-top:10px;"><label class="control-label">Roundness <span id="val-cr" class="range-val">4px</span></label><input type="range" id="cornerRadius" min="0" max="20" value="4" oninput="updateRangeLabel('cr', this.value, 'px'); renderCurrent()"></div>
        </div>

        <div class="settings-card">
            <h3>Format & Layout</h3>
            <div class="control-row"><label class="control-label">Sort</label><select id="sortOrder" onchange="renderCurrent()"><option value="value" selected>Size (Desc)</option><option value="name">A-Z</option></select></div>
            <div class="control-grid">
                <div><label class="control-label">Prefix</label><input type="text" id="valPrefix" placeholder="$" oninput="renderCurrent()"></div>
                <div><label class="control-label">Suffix</label><input type="text" id="valSuffix" placeholder="%" oninput="renderCurrent()"></div>
            </div>
            <div class="control-row" style="margin-top:15px;"><label class="control-label">Legend</label><select id="showLegend" onchange="renderCurrent()"><option value="none">None</option><option value="right">Right</option><option value="bottom">Bottom</option></select></div>
        </div>

        <div class="settings-card">
            <h3>Typography</h3>
            <div class="control-grid">
                <div><label class="control-label">Font</label><select id="fontFamily" onchange="renderCurrent()"><option value="'Segoe UI', sans-serif">Segoe UI</option><option value="Roboto, sans-serif">Roboto</option><option value="Arial, sans-serif">Arial</option></select></div>
                <div><label class="control-label">Weight</label><select id="fontWeight" onchange="renderCurrent()"><option value="normal">Normal</option><option value="bold" selected>Bold</option><option value="900">Black</option></select></div>
            </div>
            <div class="control-grid" style="margin-top:10px;">
                <div><label class="control-label">Style</label><select id="fontStyle" onchange="renderCurrent()"><option value="normal">Normal</option><option value="italic">Italic</option></select></div>
                <div><label class="control-label">Color</label><div class="color-btn" style="width:100%"><input type="color" id="labelColor" value="#333333" oninput="renderCurrent()"></div></div>
            </div>
            <div class="control-row" style="margin-top:10px;"><label class="control-label">Size <span id="val-fs" class="range-val">12px</span></label><input type="range" id="fontSize" min="8" max="40" value="12" oninput="document.getElementById('val-fs').innerText = this.value+'px'; renderCurrent()"></div>
        </div>

        <div class="settings-card">
            <h3>Labels</h3>
            <div class="control-grid">
                <div><label class="control-label">Center Type</label><select id="centerContent" onchange="renderCurrent()"><option value="total" selected>Total</option><option value="name">Root</option><option value="both">Both</option><option value="none">None</option></select></div>
                <div>
                    <label class="control-label">Custom Center</label>
                    <input type="text" id="customCenterText" placeholder="e.g. 2024" oninput="renderCurrent()" style="padding:8px; font-size:12px;">
                </div>
            </div>
            
            <div class="sub-panel" style="margin-top:15px;">
                <span class="sub-panel-title">Content per Level</span>
                <div class="control-row">
                    <label class="control-label" style="font-weight:normal;">Level 1 (Inner)</label>
                    <select id="contentL1" onchange="renderCurrent()">
                        <option value="name" selected>Name</option><option value="value">Value</option><option value="percent">Percent</option><option value="name_colon_percent">Name: %</option><option value="all">All</option><option value="none">None</option>
                    </select>
                </div>
                <div class="control-row">
                    <label class="control-label" style="font-weight:normal;">Level 2</label>
                    <select id="contentL2" onchange="renderCurrent()">
                        <option value="name" selected>Name</option><option value="value">Value</option><option value="percent">Percent</option><option value="name_colon_percent">Name: %</option><option value="all">All</option><option value="none">None</option>
                    </select>
                </div>
                <div class="control-row">
                    <label class="control-label" style="font-weight:normal;">Level 3</label>
                    <select id="contentL3" onchange="renderCurrent()">
                        <option value="name" selected>Name</option><option value="value">Value</option><option value="percent">Percent</option><option value="name_colon_percent">Name: %</option><option value="all">All</option><option value="none">None</option>
                    </select>
                </div>
                <div class="control-row">
                    <label class="control-label" style="font-weight:normal;">Level 4 (Outer)</label>
                    <select id="contentL4" onchange="renderCurrent()">
                        <option value="name" selected>Name</option><option value="value">Value</option><option value="percent">Percent</option><option value="name_colon_percent">Name: %</option><option value="all">All</option><option value="none">None</option>
                    </select>
                </div>
            </div>

            <div class="control-row" style="margin-top:10px;"><label class="control-label">Orientation</label><select id="labelOrientation" onchange="renderCurrent()"><option value="auto" selected>Auto (Radial)</option><option value="horizontal">Horizontal</option><option value="tangential">Tangential</option></select></div>
            <div class="control-row"><label class="control-label">Rotation <span id="val-rot" class="range-val">0¬∞</span></label><input type="range" id="labelRotation" min="-180" max="180" value="0" oninput="updateRangeLabel('rot', this.value, '¬∞'); renderCurrent()"></div>
            
            <div class="sub-panel">
                <span class="sub-panel-title">Positioning</span>
                <div class="control-row"><select id="labelPosition" onchange="toggleLabelControls(); renderCurrent()"><option value="inside">Inside</option><option value="outside">Outside (Pointers)</option></select></div>
                <div id="labelOffsetControl" style="margin-top:10px;">
                    <div style="background:#e3f2fd; padding:10px; border-radius:6px; font-size:11px; margin-bottom:10px; border-left:3px solid #2196f3;">
                        <strong>Tip:</strong> Hover over a line to reveal edit joints. Double-click line to add bend.
                    </div>
                    <label class="control-label" style="font-weight: normal;">Label Distance <span id="val-dist" class="range-val">25px</span></label>
                    <input type="range" id="labelDist" min="0" max="150" value="40" oninput="updateRangeLabel('dist', this.value, 'px'); renderCurrent()">
                    
                    <div style="margin-top:10px; border-top:1px dashed #ddd; padding-top:10px;">
                        <label class="control-label">Pointer Line Style</label>
                        <div class="control-row">
                            <select id="lineStyle" onchange="renderCurrent()">
                                <option value="straight" selected>Straight (Multi-Drag)</option>
                            </select>
                        </div>
                        <div class="control-grid">
                            <div><div class="color-btn" style="width:100%; height:25px;"><input type="color" id="pointerColor" value="#888888" oninput="renderCurrent()"></div></div>
                            <div><input type="number" id="pointerWidth" value="1" min="0.5" max="5" step="0.5" onchange="renderCurrent()" style="padding:4px;"></div>
                        </div>
                    </div>
                </div>
                <div class="control-row" style="margin-top:10px;"><label class="control-label">Visibility</label><select id="showLabels" onchange="renderCurrent()"><option value="auto">Auto</option><option value="all">Show All</option><option value="none">Hide All</option></select></div>
            </div>
            <div class="control-row" style="margin-top:15px;"><label class="control-label">Margin <span id="val-pad" class="range-val">50px</span></label><input type="range" id="chartPadding" min="0" max="300" value="50" oninput="updateRangeLabel('pad', this.value, 'px'); renderCurrent()"></div>
            <div class="control-grid">
                <div><label class="control-label" style="font-weight:normal;">Slice Gap <span id="val-gap" class="range-val">0px</span></label><input type="range" id="sliceGap" min="0" max="20" value="0" oninput="updateRangeLabel('gap', this.value, 'px'); renderCurrent()"></div>
                <div><label class="control-label" style="font-weight:normal;">Ring Pad <span id="val-ring" class="range-val">0px</span></label><input type="range" id="ringGap" min="0" max="20" value="0" oninput="updateRangeLabel('ring', this.value, 'px'); renderCurrent()"></div>
            </div>
        </div>
    </div>

    <div id="sidebar-footer">
        <button class="update-btn-main" onclick="syncAndRender()">
            <span style="font-size:16px;">‚ü≥</span> Update Chart Preview
        </button>
    </div>
</div>

<div id="main">
    <div id="menu-container">
        <button id="menu-btn" onclick="toggleMenu()" title="Export & Project Options">‚ò∞</button>
        <div id="main-menu">
            <div class="menu-item" onclick="exportProject()">üíæ Save Project</div>
            <div class="menu-item" onclick="document.getElementById('importFile').click()">üìÇ Load Project</div>
            <input type="file" id="importFile" style="display:none" accept=".json" onchange="importProject(this)">
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="downloadImage('svg')">üì∑ Export SVG</div>
            <div class="menu-item" onclick="downloadImage('png')">üì∑ Export PNG</div>
            <div class="menu-item" onclick="downloadImage('jpeg')">üì∑ Export JPEG</div>
            <div class="menu-separator"></div>
            <div class="menu-item danger" onclick="clearStorage()">‚ö†Ô∏è Reset Data</div>
        </div>
    </div>

    <div id="chart"></div>
    <div id="tooltip" class="tooltip"></div>
</div>

<script>
    const STORAGE_KEY = 'sunburst_editor_v6.3_crashfix';
    let activeTab = 'grid';
    let gridData = [
        { l1: "Marketing", l2: "Social", l3: "FB", l4: "", color: "#29aef6", val: 500 },
        { l1: "Marketing", l2: "Social", l3: "IG", l4: "", color: "#29aef6", val: 300 },
        { l1: "Sales", l2: "Direct", l3: "", l4: "", color: "#ff9800", val: 400 },
        { l1: "Sales", l2: "Channel", l3: "", l4: "", color: "#ff9800", val: 200 },
        { l1: "IT", l2: "Hardware", l3: "", l4: "", color: "#00e676", val: 150 },
        { l1: "IT", l2: "Software", l3: "", l4: "", color: "#00e676", val: 250 }
    ];

    const THEMES = {
        vivid: ["#FF595E", "#FFCA3A", "#8AC926", "#1982C4", "#6A4C93", "#F15BB5", "#FEE440", "#00BBF9", "#00F5D4"],
        ocean: ["#0077b6", "#0096c7", "#48cae4", "#90e0ef", "#023e8a", "#00b4d8"],
        sunset: ["#ff595e", "#ffca3a", "#8ac926", "#1982c4", "#6a4c93", "#ff924c"],
        forest: ["#2d6a4f", "#40916c", "#52b788", "#74c69d", "#b7e4c7", "#1b4332"],
        corporate: ["#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "#2b2d42"],
        neon: ["#f72585", "#7209b7", "#3a0ca3", "#4361ee", "#4cc9f0", "#b5179e"],
        berry: ["#5e548e", "#9f86c0", "#be95c4", "#e0b1cb", "#231942", "#7209b7"]
    };

    function getSettings() {
        const settings = {};
        const ids = ['chartWidth', 'chartHeight', 'chartTitle', 'colorTheme', 'visualStyle', 'textureOverlay',
                     'opL1', 'opL2', 'opL3', 'opL4', 'bgColor', 'strokeColor', 'strokeWidth', 'cornerRadius',
                     'fontFamily', 'fontWeight', 'fontStyle', 'fontSize', 'labelColor',
                     'centerContent', 'customCenterText', 'labelOrientation', 'labelRotation',
                     'contentL1', 'contentL2', 'contentL3', 'contentL4',
                     'labelPosition', 'labelDist', 'lineStyle', 'showLabels', 'chartPadding', 'sliceGap', 'ringGap',
                     'sortOrder', 'valPrefix', 'valSuffix', 'showLegend', 'pointerColor', 'pointerWidth'];

        ids.forEach(id => {
            const el = document.getElementById(id);
            if(el) settings[id] = el.value;
        });

        // SAFETY CHECKS FOR CHECKBOXES
        const bgTrans = document.getElementById('bgTransparent');
        settings['bgTransparent'] = bgTrans ? bgTrans.checked : false;

        const jsonTab = document.getElementById('showJsonTab');
        settings['showJsonTab'] = jsonTab ? jsonTab.checked : false;

        return settings;
    }

    function saveState() {
        const payload = { gridData: gridData, settings: getSettings() };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }

    function applySettings(settings) {
        if(!settings) return;
        Object.keys(settings).forEach(key => {
            const el = document.getElementById(key);
            if(el) {
                if(key === 'bgTransparent' || key === 'showJsonTab') el.checked = settings[key];
                else el.value = settings[key];
            }
        });
        toggleJsonTab();
        updateRangeLabel('fs', document.getElementById('fontSize').value, 'px');
        updateRangeLabel('rot', document.getElementById('labelRotation').value, '¬∞');
        updateRangeLabel('dist', document.getElementById('labelDist').value, 'px');
        updateRangeLabel('pad', document.getElementById('chartPadding').value, 'px');
        updateRangeLabel('gap', document.getElementById('sliceGap').value, 'px');
        updateRangeLabel('ring', document.getElementById('ringGap').value, 'px');
        updateRangeLabel('sw', document.getElementById('strokeWidth').value, 'px');
        updateRangeLabel('cr', document.getElementById('cornerRadius').value, 'px');
    }

    function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return;
        try {
            const data = JSON.parse(raw);
            if(data.gridData && Array.isArray(data.gridData)) gridData = data.gridData;
            if(data.settings) applySettings(data.settings);
        } catch(e) { console.log("Error loading state", e); }
    }

    function toggleJsonTab() {
        const show = document.getElementById('showJsonTab').checked;
        document.getElementById('btn-json').style.display = show ? 'block' : 'none';
        if(!show && activeTab === 'json') switchTab('grid');
    }

    function toggleMenu() {
        const menu = document.getElementById('main-menu');
        menu.classList.toggle('show');
    }

    document.addEventListener('click', function(e) {
        const container = document.getElementById('menu-container');
        if (!container.contains(e.target)) {
            document.getElementById('main-menu').classList.remove('show');
        }
    });

    function exportProject() {
        const payload = { gridData: gridData, settings: getSettings() };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(payload, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "sunburst_project.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    }

    function importProject(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                if(data.gridData && Array.isArray(data.gridData)) gridData = data.gridData;
                if(data.settings) applySettings(data.settings);
                renderGridRows();
                syncAndRender();
                alert("Project loaded successfully!");
            } catch(err) {
                alert("Error loading project file: " + err);
            }
        };
        reader.readAsText(file);
    }

    function clearStorage() {
        if(confirm("Reset all settings and data to default?")) {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }
    }

    function init() { 
        loadState();
        toggleLabelControls(); 
        renderGridRows(); 
        syncGridToJson(); 
        toggleBgColor(); 
        toggleJsonTab();
    }

    function switchTab(t) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        const btn = document.getElementById(`btn-${t}`);
        if(btn) btn.classList.add('active');
        const content = document.getElementById(`tab-${t}`);
        content.classList.add('active');
        if (activeTab === 'grid' && t === 'json') syncGridToJson();
        activeTab = t;
    }
    
    function toggleImport() {
        const body = document.getElementById('import-body');
        const arrow = document.getElementById('import-arrow');
        if(body.classList.contains('open')) {
            body.classList.remove('open');
            arrow.innerText = '‚ñº';
        } else {
            body.classList.add('open');
            arrow.innerText = '‚ñ≤';
        }
    }

    function updateRangeLabel(id, val, suffix) { 
        const el = document.getElementById(`val-${id}`);
        if(el) el.innerText = val + suffix; 
    }
    
    function toggleLabelControls() {
        const pos = document.getElementById('labelPosition').value;
        const ctrl = document.getElementById('labelOffsetControl');
        ctrl.style.display = (pos === 'outside') ? 'block' : 'none';
    }
    
    function toggleBgColor() {
        document.getElementById('bgColor').disabled = document.getElementById('bgTransparent').checked;
        renderCurrent();
    }

    function applyThemeReset() {
        gridData.forEach(row => { row.color = "#000000"; });
        const wrappers = document.querySelectorAll('.color-wrapper');
        wrappers.forEach(w => {
            w.querySelector('input[type="color"]').value = "#000000";
            w.querySelector('.hex-input').value = "#000000";
        });
        syncAndRender();
    }

    function parseCSV() {
        const txt = document.getElementById('csvInput').value.trim();
        if(!txt) return;
        const rows = txt.split(/\r?\n/);
        const newData = [];
        
        rows.forEach(r => {
            let cols = r.split(/\t/);
            if(cols.length < 2) cols = r.split(/,/);
            if(cols.length) {
                const l1 = cols[0] ? cols[0].trim() : "";
                const l2 = cols[1] ? cols[1].trim() : "";
                const l3 = cols[2] ? cols[2].trim() : "";
                const l4 = cols[3] ? cols[3].trim() : "";
                let val = 0;
                if(cols.length >= 5 && !isNaN(cols[4])) val = parseFloat(cols[4]);
                else if(cols.length > 0) {
                     const last = cols[cols.length-1].trim();
                     if(!isNaN(last)) val = parseFloat(last);
                }
                if(l1) newData.push({l1, l2, l3, l4, color: "#000000", val});
            }
        });

        if(newData.length > 0) {
            gridData = newData;
            renderGridRows();
            syncAndRender();
            alert(`Imported ${newData.length} rows successfully!`);
            toggleImport(); 
        } else {
            alert("Could not parse CSV. Check format.");
        }
    }

    function renderGridRows() {
        const c = document.getElementById('rows-container'); c.innerHTML = '';
        gridData.forEach((r, i) => {
            const d = document.createElement('div'); d.className = 'data-row';
            const col = r.color || "#000000"; 
            d.innerHTML = `
                <input type="text" class="lvl-input" value="${r.l1}" onchange="updateGridData(${i}, 'l1', this.value)">
                <input type="text" class="lvl-input" value="${r.l2}" onchange="updateGridData(${i}, 'l2', this.value)">
                <input type="text" class="lvl-input" value="${r.l3}" onchange="updateGridData(${i}, 'l3', this.value)">
                <input type="text" class="lvl-input" value="${r.l4}" onchange="updateGridData(${i}, 'l4', this.value)">
                <div class="color-wrapper">
                    <input type="color" value="${col}" oninput="handleColorChange(${i}, this.value, 'picker')">
                    <input type="text" class="hex-input" value="${col}" oninput="handleColorChange(${i}, this.value, 'text')">
                </div>
                <input type="number" class="val-input" value="${r.val}" onchange="updateGridData(${i}, 'val', this.value)">
                <div class="del-cell" onclick="removeGridRow(${i})">√ó</div>`;
            c.appendChild(d);
        });
    }
    
    function addGridRow() { 
        const prev = gridData.length ? gridData[gridData.length-1] : null;
        const l1 = prev ? prev.l1 : "";
        const col = prev ? prev.color : "#000000";
        gridData.push({l1: l1, l2:"", l3:"", l4:"", color: col, val:0}); 
        renderGridRows(); 
        saveState();
    }
    function removeGridRow(i) { gridData.splice(i, 1); renderGridRows(); saveState(); }
    function updateGridData(i, k, v) { gridData[i][k] = v; saveState(); }

    function handleColorChange(idx, val, source) {
        if (source === 'text' && !/^#[0-9A-F]{6}$/i.test(val)) return;
        updateGridData(idx, 'color', val);
        const row = document.getElementById('rows-container').children[idx];
        if(source === 'picker') row.querySelector('.hex-input').value = val;
        if(source === 'text') row.querySelector('input[type="color"]').value = val;
        syncAndRender();
    }

    function syncGridToJson() {
        const rootName = gridData[0]?.l1 || "Root";
        const root = { name: rootName, children: [] };
        gridData.forEach(r => {
            if(!r.l1) return;
            let l1 = root.children.find(c => c.name === r.l1);
            if(!l1) { l1 = { name: r.l1, children: [] }; if(r.color!=="#000000") l1.color = r.color; root.children.push(l1); }
            if(!r.l2 && !r.l3 && !r.l4) { if((+r.val||0)>0) l1.value=(l1.value||0)+(+r.val); return; }

            let l2 = l1.children.find(c => c.name === r.l2);
            if(!l2 && r.l2) { l2 = { name: r.l2, children: [] }; l1.children.push(l2); }
            if(!l2) return;
            if(!r.l3 && !r.l4) { if((+r.val||0)>0) l2.value=(l2.value||0)+(+r.val); return; }

            let l3 = l2.children.find(c => c.name === r.l3);
            if(!l3 && r.l3) { l3 = { name: r.l3, children: [] }; l2.children.push(l3); }
            if(!l3) return;
            if(!r.l4) { if((+r.val||0)>0) l3.value=(l3.value||0)+(+r.val); return; }

            let l4 = l3.children.find(c => c.name === r.l4);
            if(!l4 && r.l4) { if((+r.val||0)>0) { l4 = { name: r.l4, value: +r.val }; l3.children.push(l4); } }
        });
        document.getElementById('jsonInput').value = JSON.stringify(root, null, 2);
        renderChart(root);
    }
    
    function syncAndRender() {
        saveState(); 
        if(activeTab === 'grid') syncGridToJson();
        else try { renderChart(JSON.parse(document.getElementById('jsonInput').value)); } catch(e) { alert("Invalid JSON"); }
    }
    function renderCurrent() { syncAndRender(); }

    function renderChart(data) {
        d3.select("#chart").html("");
        
        const width = parseInt(document.getElementById('chartWidth').value) || 1000;
        const height = parseInt(document.getElementById('chartHeight').value) || 1000;
        const title = document.getElementById('chartTitle').value;
        const fontFamily = document.getElementById('fontFamily').value;
        const fontSize = document.getElementById('fontSize').value + 'px';
        const fontWeight = document.getElementById('fontWeight').value;
        const fontStyle = document.getElementById('fontStyle').value;
        const labelColor = document.getElementById('labelColor').value || "#ffffff";
        const themeVal = document.getElementById('colorTheme').value;
        const visualStyle = document.getElementById('visualStyle').value;
        
        const textureOverlay = document.getElementById('textureOverlay').value;
        const strokeColor = document.getElementById('strokeColor').value;
        const strokeWidth = parseFloat(document.getElementById('strokeWidth').value);
        const cornerRadius = parseFloat(document.getElementById('cornerRadius').value);

        const labelPosEl = document.getElementById('labelPosition');
        const labelPosition = labelPosEl ? labelPosEl.value : 'inside';
        const labelRotEl = document.getElementById('labelRotation');
        const rotationOffset = labelRotEl ? (parseInt(labelRotEl.value) || 0) : 0;
        const labelOrEl = document.getElementById('labelOrientation');
        const orientation = labelOrEl ? labelOrEl.value : 'auto';
        
        const lineStyle = document.getElementById('lineStyle').value;

        const padding = parseInt(document.getElementById('chartPadding').value) || 50;
        const sliceGap = parseFloat(document.getElementById('sliceGap').value) || 0;
        const ringGap = parseFloat(document.getElementById('ringGap').value) || 0;
        const labelDist = parseInt(document.getElementById('labelDist').value) || 10;
        const showLabels = document.getElementById('showLabels').value;
        
        // --- MULTI-LEVEL CONTENT ---
        const contentL1 = document.getElementById('contentL1').value;
        const contentL2 = document.getElementById('contentL2').value;
        const contentL3 = document.getElementById('contentL3').value;
        const contentL4 = document.getElementById('contentL4').value;

        const centerContent = document.getElementById('centerContent').value;
        const customCenterText = document.getElementById('customCenterText').value;
        
        const pointerColor = document.getElementById('pointerColor').value;
        const pointerWidth = document.getElementById('pointerWidth').value;
        const sortOrder = document.getElementById('sortOrder').value;
        const valPrefix = document.getElementById('valPrefix').value;
        const valSuffix = document.getElementById('valSuffix').value;
        const showLegend = document.getElementById('showLegend').value;
        
        const bgTrans = document.getElementById('bgTransparent').checked;
        const bgColor = document.getElementById('bgColor').value;

        const opL1 = parseFloat(document.getElementById('opL1').value) || 1;
        const opL2 = parseFloat(document.getElementById('opL2').value) || 1;
        const opL3 = parseFloat(document.getElementById('opL3').value) || 1;
        const opL4 = parseFloat(document.getElementById('opL4').value) || 1;

        const svg = d3.select("#chart").append("svg")
            .attr("width", width).attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("xmlns", "http://www.w3.org/2000/svg").style("font-family", fontFamily);
        
        if(!bgTrans) svg.style("background-color", bgColor);

        const defs = svg.append("defs");
        
        const patLines = defs.append("pattern").attr("id", "pat-lines").attr("width", 8).attr("height", 8).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)");
        patLines.append("rect").attr("width",4).attr("height",8).attr("transform","translate(0,0)").attr("fill", "rgba(255,255,255,0.15)");
        
        const patDots = defs.append("pattern").attr("id", "pat-dots").attr("width", 6).attr("height", 6).attr("patternUnits", "userSpaceOnUse");
        patDots.append("circle").attr("cx", 3).attr("cy", 3).attr("r", 1.5).attr("fill", "rgba(255,255,255,0.2)");

        const patGrid = defs.append("pattern").attr("id", "pat-grid").attr("width", 8).attr("height", 8).attr("patternUnits", "userSpaceOnUse");
        patGrid.append("path").attr("d", "M 8 0 L 0 0 0 8").attr("fill", "none").attr("stroke", "rgba(255,255,255,0.2)").attr("stroke-width", 1);

        const shadow = defs.append("filter").attr("id", "drop-shadow").attr("height", "130%");
        shadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 4);
        shadow.append("feOffset").attr("dx", 3).attr("dy", 3).attr("result", "offsetblur");
        shadow.append("feFlood").attr("flood-color", "rgba(0,0,0,0.2)");
        shadow.append("feComposite").attr("in2", "offsetblur").attr("operator", "in");
        const merge = shadow.append("feMerge");
        merge.append("feMergeNode");
        merge.append("feMergeNode").attr("in", "SourceGraphic");

        const bevel = defs.append("filter").attr("id", "bevel-filter")
            .attr("x", "-50%").attr("y", "-50%").attr("width", "200%").attr("height", "200%");
        bevel.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 2).attr("result", "blur");
        bevel.append("feSpecularLighting").attr("in", "blur").attr("surfaceScale", 5)
            .attr("specularConstant", 0.5).attr("specularExponent", 10)
            .attr("result", "specOut").attr("lighting-color", "white")
            .append("fePointLight").attr("x", -5000).attr("y", -10000).attr("z", 20000);
        bevel.append("feComposite").attr("in", "specOut").attr("in2", "SourceAlpha").attr("operator", "in").attr("result", "specOut");
        bevel.append("feComposite").attr("in", "SourceGraphic").attr("in2", "specOut")
            .attr("operator", "arithmetic").attr("k1", 0).attr("k2", 1).attr("k3", 1).attr("k4", 0);

        const glow = defs.append("filter").attr("id", "glow-filter");
        glow.append("feGaussianBlur").attr("stdDeviation", "2.5").attr("result", "coloredBlur");
        const mergeGlow = glow.append("feMerge");
        mergeGlow.append("feMergeNode").attr("in", "coloredBlur");
        mergeGlow.append("feMergeNode").attr("in", "SourceGraphic");

        let filterUrl = null;
        if(visualStyle === 'shadow') filterUrl = "url(#drop-shadow)";
        if(visualStyle === 'bevel') filterUrl = "url(#bevel-filter)";
        if(visualStyle === 'glow') filterUrl = "url(#glow-filter)";

        const titleH = title ? 60 : 0;
        let legendW = 0;
        let legendH = 0;
        if(showLegend === 'right') legendW = 150;
        if(showLegend === 'bottom') legendH = 100;

        if(title) {
            svg.append("text")
               .attr("x", (width - legendW)/2).attr("y", 45)
               .attr("text-anchor", "middle")
               .style("font-size", "28px").style("font-weight", "800").style("fill", "#212529").text(title);
        }

        const chartCenterX = (width - legendW) / 2;
        const chartCenterY = (height - legendH) / 2 + (titleH/2);
        const g = svg.append("g").attr("transform", `translate(${chartCenterX}, ${chartCenterY})`);

        const effW = Math.max(10, width - legendW - (padding * 2));
        const effH = Math.max(10, height - legendH - titleH - (padding * 2));
        const r = Math.min(effW, effH) / 2;

        let colorScale;
        if(THEMES[themeVal]) colorScale = d3.scaleOrdinal(THEMES[themeVal]);
        else colorScale = d3.scaleOrdinal(d3[themeVal]);

        const hierarchy = d3.hierarchy(data).sum(d=>d.value);
        if(sortOrder === 'value') hierarchy.sort((a,b)=>b.value-a.value);
        else hierarchy.sort((a,b)=> d3.ascending(a.data.name, b.data.name));

        // Assign unique IDs
        hierarchy.descendants().forEach((d, i) => d.uniqueId = `node-${d.depth}-${i}`);

        const root = d3.partition().size([2*Math.PI, r])(hierarchy);

        const arc = d3.arc().startAngle(d=>d.x0).endAngle(d=>d.x1)
            .padAngle(sliceGap * 0.005).padRadius(r/2)
            .innerRadius(d=>d.y0).outerRadius(d => Math.max(d.y0, d.y1 - ringGap))
            .cornerRadius(cornerRadius);

        const slices = g.selectAll("path").data(root.descendants().filter(d=>d.depth && d.value > 0)).join("g");
        
        slices.append("path")
            .attr("fill", d => {
                if(d.data.color && d.data.color !== "#000000") return d.data.color;
                let anc = d.parent; while(anc) { if(anc.data.color && anc.data.color !== "#000000") return anc.data.color; anc = anc.parent; }
                let l1 = d; while(l1.depth > 1) l1 = l1.parent;
                return colorScale(l1.data.name);
            })
            .attr("stroke", strokeColor)
            .attr("stroke-width", strokeWidth)
            .attr("opacity", d => {
                if (d.depth === 1) return opL1;
                if (d.depth === 2) return opL2;
                if (d.depth === 3) return opL3;
                if (d.depth >= 4) return opL4;
                return 1;
            })
            .attr("d", arc)
            .style("filter", filterUrl)
            .on("mouseover", (e,d)=>{
                const pVal = d.value.toLocaleString();
                const pPct = root.value>0 ? ((d.value/root.value)*100).toFixed(1) : 0;
                d3.select("#tooltip").style("opacity",1).html(`<strong>${d.data.name}</strong><br>${valPrefix}${pVal}${valSuffix} (${pPct}%)`)
                  .style("left", e.pageX+"px").style("top", e.pageY+"px");
            }).on("mouseout", ()=>d3.select("#tooltip").style("opacity",0));

        if(textureOverlay !== 'none') {
            slices.append("path")
                .attr("d", arc)
                .attr("fill", `url(#pat-${textureOverlay})`)
                .style("pointer-events", "none")
                .attr("opacity", d => {
                     if (d.depth === 1) return opL1;
                     if (d.depth === 2) return opL2;
                     if (d.depth === 3) return opL3;
                     if (d.depth >= 4) return opL4;
                     return 1;
                });
        }

        if(showLabels !== 'none') {
            const labelNodes = root.descendants().filter(d => d.depth && d.value > 0 && (showLabels==='all' || (d.y0+d.y1)/2*(d.x1-d.x0)>10));
            
            // POINTER LINES LAYER
            if(labelPosition === 'outside') {
                const pointersGroup = g.append("g").attr("class", "pointers-layer");
                
                labelNodes.filter(d => !d.children).forEach(d => {
                    const angle = (d.x0 + d.x1) / 2;
                    const outerR = Math.max(d.y0, d.y1 - ringGap);
                    
                    // Initialize or use existing points
                    if (!d.polyPoints) {
                        const p1x = Math.cos(angle - Math.PI/2) * outerR;
                        const p1y = Math.sin(angle - Math.PI/2) * outerR;
                        const targetR = r + labelDist;
                        const p2x = Math.cos(angle - Math.PI/2) * targetR;
                        const p2y = Math.sin(angle - Math.PI/2) * targetR;
                        
                        d.polyPoints = [
                            {x: p1x, y: p1y, fixed: true}, // Start
                            {x: p2x, y: p2y, fixed: false} // End
                        ];
                    } else {
                        // Update start point
                        const p1x = Math.cos(angle - Math.PI/2) * outerR;
                        const p1y = Math.sin(angle - Math.PI/2) * outerR;
                        d.polyPoints[0] = {x: p1x, y: p1y, fixed: true};
                    }

                    // GROUP WRAPPER for Hover Effect
                    const lineGroup = pointersGroup.append("g").attr("class", "line-wrapper line-group-" + d.uniqueId);

                    const updateLine = () => {
                        lineGroup.html(""); // Clear

                        const pointsStr = d.polyPoints.map(p => `${p.x},${p.y}`).join(" ");

                        // Visual Line
                        lineGroup.append("polyline")
                            .attr("class", "pointer-line")
                            .attr("id", "line-" + d.uniqueId)
                            .style("stroke", pointerColor)
                            .style("stroke-width", pointerWidth)
                            .attr("fill", "none")
                            .attr("points", pointsStr);

                        // Invisible Hit Area
                        lineGroup.append("polyline")
                            .attr("class", "pointer-hit-area")
                            .attr("points", pointsStr)
                            .on("dblclick", function(event) {
                                event.stopPropagation();
                                const [mx, my] = d3.pointer(event);
                                const newPoint = {x: mx, y: my, fixed: false};
                                d.polyPoints.splice(d.polyPoints.length - 1, 0, newPoint);
                                updateLine();
                            });

                        // Handles (Joints)
                        d.polyPoints.forEach((p, index) => {
                            if (index > 0 && index < d.polyPoints.length - 1) {
                                const handle = lineGroup.append("circle")
                                    .attr("class", "control-handle")
                                    .attr("r", 4)
                                    .attr("cx", p.x)
                                    .attr("cy", p.y)
                                    .on("dblclick", function(event) {
                                        event.stopPropagation();
                                        d.polyPoints.splice(index, 1);
                                        updateLine();
                                    });
                                
                                handle.call(d3.drag()
                                    .on("start", function() { d3.select(this).classed("dragging", true); })
                                    .on("drag", function(event) {
                                        p.x += event.dx;
                                        p.y += event.dy;
                                        updateLine();
                                    })
                                    .on("end", function() { d3.select(this).classed("dragging", false); })
                                );
                            }
                        });
                    };

                    updateLine();
                });
            }

            const labels = g.append("g").attr("class", "labels-layer")
                .selectAll("text")
                .data(labelNodes)
                .join("text")
                .attr("class", "draggable")
                .attr("dy", "0.35em")
                .style("font-size", fontSize)
                .style("font-weight", d => (labelPosition === 'outside' && !d.children) ? "bold" : fontWeight)
                .style("font-style", fontStyle)
                .style("fill", labelColor)
                .style("text-shadow", d => (labelPosition === 'outside' && !d.children) ? "none" : "0 0 3px rgba(0,0,0,0.6)")
                .text(d => {
                    let valStr = `${valPrefix}${d.value}${valSuffix}`;
                    let pct = root.value>0 ? ((d.value / root.value) * 100).toFixed(1)+"%" : "0%";
                    
                    // LEVEL BASED FORMATTING LOGIC
                    let contentMode = 'name';
                    if(d.depth === 1) contentMode = contentL1;
                    else if(d.depth === 2) contentMode = contentL2;
                    else if(d.depth === 3) contentMode = contentL3;
                    else if(d.depth === 4) contentMode = contentL4;
                    
                    if (contentMode === 'none') return "";
                    if (contentMode === 'percent') return pct;
                    if (contentMode === 'name_percent') return `${d.data.name} (${pct})`;
                    if (contentMode === 'name_colon_percent') return `${d.data.name}: ${pct}`;
                    if (contentMode === 'name_value') return `${d.data.name} (${valStr})`;
                    if (contentMode === 'all') return `${d.data.name}: ${valStr} (${pct})`;
                    if (contentMode === 'value') return valStr;
                    return d.data.name;
                });

            labels.each(function(d) {
                // Check if hidden by level
                let contentMode = 'name';
                if(d.depth === 1) contentMode = contentL1;
                else if(d.depth === 2) contentMode = contentL2;
                else if(d.depth === 3) contentMode = contentL3;
                else if(d.depth === 4) contentMode = contentL4;
                
                if(contentMode === 'none') {
                    d3.select(this).style("display", "none");
                    return;
                }

                if (labelPosition === 'outside' && !d.children && d.polyPoints) {
                    const lastP = d.polyPoints[d.polyPoints.length - 1];
                    let anchor = "middle";
                    if (orientation === 'horizontal') {
                         if (lastP.x > 0) anchor = "start"; 
                         else anchor = "end"; 
                         d3.select(this).attr("dx", lastP.x > 0 ? "5px" : "-5px");
                    }
                    d3.select(this)
                      .attr("transform", `translate(${lastP.x},${lastP.y})`)
                      .attr("text-anchor", anchor);
                } else {
                    const angle = (d.x0 + d.x1) / 2; 
                    let radius = (d.y0 + d.y1) / 2;
                    if (labelPosition === 'outside' && !d.children) radius = r + labelDist;
                    const cx = radius * Math.cos(angle - Math.PI/2);
                    const cy = radius * Math.sin(angle - Math.PI/2);
                    let rotate = 0;
                    const degrees = (angle * 180 / Math.PI) - 90;
                    let anchor = "middle";
                    if(orientation === 'auto') {
                        rotate = degrees;
                        if (rotate > 90) rotate += 180; 
                        if (rotate < -90) rotate += 180;
                    } else if (orientation === 'tangential') {
                        rotate = degrees + 90;
                    }
                    rotate += rotationOffset;
                    d3.select(this)
                      .attr("transform", `translate(${cx},${cy}) rotate(${rotate})`)
                      .attr("text-anchor", anchor);
                }
            });

            // DRAG TEXT
            labels.call(d3.drag()
                .on("start", function() { d3.select(this).raise(); })
                .on("drag", function(event, d) {
                    const t = d3.select(this).attr("transform");
                    const translate = t.match(/translate\(([^,]+),([^)]+)\)/);
                    let currX = parseFloat(translate[1]);
                    let currY = parseFloat(translate[2]);
                    currX += event.dx;
                    currY += event.dy;
                    
                    const rotateStr = t.match(/rotate\([^)]+\)/) ? t.match(/rotate\([^)]+\)/)[0] : "";
                    d3.select(this).attr("transform", `translate(${currX},${currY}) ${rotateStr}`);

                    if(labelPosition === 'outside' && !d.children && d.polyPoints) {
                        const lastIdx = d.polyPoints.length - 1;
                        d.polyPoints[lastIdx].x = currX;
                        d.polyPoints[lastIdx].y = currY;
                        
                        const pointsStr = d.polyPoints.map(p => `${p.x},${p.y}`).join(" ");
                        d3.select(`.line-group-${d.uniqueId} .pointer-line`).attr("points", pointsStr);
                        d3.select(`.line-group-${d.uniqueId} .pointer-hit-area`).attr("points", pointsStr);
                    }
                })
            );
        }

        const cg = g.append("g").attr("text-anchor","middle").style("fill","#333");
        
        if (customCenterText && customCenterText.trim() !== "") {
            cg.append("text").text(customCenterText)
              .attr("dy", "0.35em")
              .style("font-size", "24px")
              .style("font-weight", "800");
        } else if (centerContent !== 'none') {
            const tot = Math.round(root.value);
            const totStr = `${valPrefix}${tot}${valSuffix}`;
            if(centerContent === 'total') cg.append("text").text(totStr).attr("dy", "0.3em").style("font-size", "32px").style("font-weight", "800");
            else if(centerContent === 'name') cg.append("text").text(root.data.name).attr("dy", "0.3em").style("font-size", "22px").style("font-weight", "bold");
            else {
                cg.append("text").text(root.data.name).attr("dy", "-0.3em").style("font-size", "14px").style("fill", "#666");
                cg.append("text").text(totStr).attr("dy", "1.0em").style("font-size", "24px").style("font-weight", "bold");
            }
        }

        if(showLegend !== 'none') {
            const legG = svg.append("g");
            const items = root.children || []; 
            if(showLegend === 'right') {
                legG.attr("transform", `translate(${width - 140}, 50)`);
                items.forEach((d, i) => {
                   const lg = legG.append("g").attr("transform", `translate(0, ${i * 25})`);
                   lg.append("rect").attr("width", 15).attr("height", 15).attr("fill", d.data.color && d.data.color!=="#000000" ? d.data.color : colorScale(d.data.name)).attr("rx",3);
                   lg.append("text").attr("x", 20).attr("y", 12).text(d.data.name).style("font-size", "12px").style("font-weight", "600").style("fill", "#444");
                });
            } else if (showLegend === 'bottom') {
                legG.attr("transform", `translate(20, ${height - 60})`);
                let xOffset = 0;
                items.forEach((d, i) => {
                   const lg = legG.append("g").attr("transform", `translate(${xOffset}, 0)`);
                   lg.append("rect").attr("width", 15).attr("height", 15).attr("fill", d.data.color && d.data.color!=="#000000" ? d.data.color : colorScale(d.data.name)).attr("rx",3);
                   const txt = lg.append("text").attr("x", 20).attr("y", 12).text(d.data.name).style("font-size", "12px").style("font-weight", "600").style("fill", "#444");
                   const w = txt.node().getComputedTextLength();
                   xOffset += (w + 40);
                });
            }
        }
    }

    function downloadImage(format) {
        const svgEl = document.querySelector("svg");
        let svgData = new XMLSerializer().serializeToString(svgEl);
        const w = parseInt(svgEl.getAttribute("width"));
        const h = parseInt(svgEl.getAttribute("height"));
        
        if (format === 'svg') {
            const bgTrans = document.getElementById('bgTransparent').checked;
            const bgColor = document.getElementById('bgColor').value;
            if(!bgTrans) {
                const bgRect = `<rect width="100%" height="100%" fill="${bgColor}"/>`;
                svgData = svgData.replace('>', `>${bgRect}`);
            }
            const blob = new Blob([svgData.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"')], {type: "image/svg+xml;charset=utf-8"});
            triggerDownload(URL.createObjectURL(blob), "sunburst_chart.svg");
            return;
        }
        
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const img = new Image();
        canvas.width = w; canvas.height = h;
        const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
        const url = URL.createObjectURL(svgBlob);
        
        img.onload = function() {
            const bgTrans = document.getElementById('bgTransparent').checked;
            const bgColor = document.getElementById('bgColor').value;
            if (format === 'jpeg') {
                ctx.fillStyle = bgTrans ? "#ffffff" : bgColor;
                ctx.fillRect(0, 0, w, h);
            } else if (format === 'png' && !bgTrans) {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, w, h);
            }
            ctx.drawImage(img, 0, 0, w, h);
            triggerDownload(canvas.toDataURL(`image/${format}`, 0.9), `sunburst_chart.${format}`);
            URL.revokeObjectURL(url);
        };
        img.src = url;
    }
    function triggerDownload(url, filename) {
        const link = document.createElement("a"); link.href = url; link.download = filename;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }

    init();
</script>
</body>
</html>
