<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Frequency - Level 5: The Marathon</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
            touch-action: none;
            user-select: none;
        }
        canvas {
            border: 2px solid #ffffff; 
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.2);
            background: #111;
            max-width: 100%; max-height: 100%;
        }
        #ui {
            position: absolute; top: 30px;
            width: 100%; text-align: center; pointer-events: none;
            text-shadow: 0 1px 2px black; z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; letter-spacing: 4px; text-transform: uppercase; color: #fff; }
        #chapter-text { font-size: 16px; color: #aaa; margin-top: 5px; font-weight: bold; text-transform: uppercase;}
        #score { font-size: 12px; color: #fff; margin-top: 5px; opacity: 0.6; }
        
        /* CHECKPOINT MESSAGE STYLE */
        #checkpoint-msg {
            position: absolute; top: 20%; width: 100%; text-align: center;
            color: #00ffff; font-weight: bold; font-size: 16px; letter-spacing: 2px;
            text-shadow: 0 0 10px cyan; opacity: 0; transition: opacity 0.5s;
            pointer-events: none; z-index: 15;
        }

        #start-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 20px; text-align: center;
            animation: blink 0.5s infinite; pointer-events: none; 
        }
        
        #win-msg {
            display: none; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); text-align: center; color: #fff; z-index: 20;
        }
        #win-msg h2 { font-size: 40px; text-shadow: 0 0 20px #fff; margin-bottom: 10px; }

        #mobile-controls {
            position: absolute; bottom: 20px; width: 100%; height: 120px;
            pointer-events: none; display: flex; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box; z-index: 100;
        }
        .control-group { pointer-events: auto; display: flex; gap: 15px; align-items: flex-end; }
        .touch-btn {
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; color: rgba(255, 255, 255, 0.8); display: flex;
            justify-content: center; align-items: center; font-size: 24px;
            backdrop-filter: blur(4px); touch-action: manipulation;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.3); border-color: #fff; color: #fff; }
        #btn-left, #btn-right { width: 70px; height: 70px; }
        #btn-jump { width: 80px; height: 80px; margin-bottom: 10px; }
        #btn-pulse { width: 60px; height: 60px; font-size: 14px; margin-bottom: 20px; border-color: rgba(0,255,255,0.4); color: #00ffff; }
        #btn-shoot { width: 60px; height: 60px; font-size: 14px; margin-bottom: 10px; border-color: rgba(255, 80, 80, 0.6); color: #ff5555; }

        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div id="ui">
    <h1>The Frequency</h1>
    <div id="chapter-text">LEVEL 5: THE STATIC VOID</div>
    <div id="score">0m / 50000m</div>
</div>

<div id="checkpoint-msg"></div>

<div id="start-msg">TAP / PRESS ANY KEY TO START<br><span style="font-size:14px; color:#aaa;">Target: The Source (50,000m)</span></div>

<div id="win-msg">
    <h2>SIGNAL SOURCE LOCATED</h2>
    <p>The End is Beginning.</p>
    <button onclick="location.reload()" style="margin-top:20px; padding:10px 20px; background:transparent; border:1px solid #fff; color:#fff; cursor:pointer;">REPLAY GAME</button>
</div>

<div id="mobile-controls">
    <div class="control-group"><div class="touch-btn" id="btn-left">←</div><div class="touch-btn" id="btn-right">→</div></div>
    <div class="control-group"><div class="touch-btn" id="btn-shoot">G</div><div class="touch-btn" id="btn-pulse">F</div><div class="touch-btn" id="btn-jump">▲</div></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const winEl = document.getElementById('win-msg');
    const startMsg = document.getElementById('start-msg');
    const checkEl = document.getElementById('checkpoint-msg');

    function resize() { canvas.width = 800; canvas.height = 450; }
    resize(); window.addEventListener('resize', resize);

    const Audio = {
        ctx: null,
        init: function() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            startMsg.style.display = 'none';
        },
        playTone: function(freq, type, duration, vol=0.1) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        },
        jump: function() { this.playTone(200, 'sine', 0.1, 0.1); },
        glitch: function() { this.playTone(100, 'sawtooth', 0.05, 0.05); },
        pulse: function() { this.playTone(800, 'sine', 0.3, 0.1); },
        laser: function() { this.playTone(600, 'sawtooth', 0.1, 0.1); },
        crash: function() { this.playTone(50, 'square', 0.4, 0.3); },
        save: function() { this.playTone(400, 'sine', 0.5, 0.2); } // Checkpoint sound
    };

    const GRAVITY = 0.6; 
    const GROUND_FRICTION = 0.8; const AIR_RESISTANCE = 0.98; 
    const MOVE_SPEED = 0.8; const MAX_SPEED = 6; const JUMP_FORCE = 14;
    const PLAYER_START_X = 100;
    
    // *** UPDATED DISTANCE ***
    const WIN_DIST = 50000; 
    const CHECKPOINT_INTERVAL = 5000; // Save every 5000m

    let frame = 0; let camX = 0; let camY = 0; let camZoom = 1.0;
    let distanceTraveled = 0; let gameState = "PLAYING"; 
    let lastCheckpoint = { x: PLAYER_START_X, y: 300 };
    let nextCheckpointDist = CHECKPOINT_INTERVAL;

    const keys = { right: false, left: false, up: false, f: false, g: false };

    function activateAudio() { Audio.init(); }

    function handleTouch(btnId, keyName, isPressed) {
        const btn = document.getElementById(btnId);
        const startAction = (e) => {
            e.preventDefault(); activateAudio();
            if (keyName === 'f' && !keys.f && isPressed) createPulse();
            if (keyName === 'g' && !keys.g && isPressed) fireLaser();
            if (keyName === 'up' && !keys.up && isPressed && player.coyoteTimer > 0) {
                 player.velY = -JUMP_FORCE; player.grounded = false; player.coyoteTimer = 0; Audio.jump();
            }
            keys[keyName] = true;
        };
        const endAction = (e) => { e.preventDefault(); keys[keyName] = false; };
        btn.addEventListener('touchstart', startAction, {passive: false});
        btn.addEventListener('touchend', endAction, {passive: false});
        btn.addEventListener('mousedown', startAction); btn.addEventListener('mouseup', endAction);
    }
    handleTouch('btn-left', 'left'); handleTouch('btn-right', 'right');
    handleTouch('btn-jump', 'up'); handleTouch('btn-pulse', 'f');
    handleTouch('btn-shoot', 'g');

    window.addEventListener('keydown', (e) => {
        activateAudio();
        if(gameState === "WON") return;
        if(e.code === 'ArrowRight') keys.right = true;
        if(e.code === 'ArrowLeft') keys.left = true;
        if(e.code === 'Space' || e.code === 'ArrowUp') {
            if(!keys.up && player.coyoteTimer > 0) { player.velY = -JUMP_FORCE; player.grounded = false; player.coyoteTimer = 0; Audio.jump(); }
            keys.up = true;
        }
        if(e.code === 'KeyF') { if(!keys.f) createPulse(); keys.f = true; }
        if(e.code === 'KeyG') { if(!keys.g) fireLaser(); keys.g = true; }
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'ArrowRight') keys.right = false; if(e.code === 'ArrowLeft') keys.left = false;
        if(e.code === 'Space' || e.code === 'ArrowUp') keys.up = false; 
        if(e.code === 'KeyF') keys.f = false; if(e.code === 'KeyG') keys.g = false;
    });

    // --- ENTITIES ---

    class Platform {
        constructor(x, y, w, h) {
            this.x = x; this.y = y; this.w = w; this.h = h;
        }
        draw() {
            const drawX = this.x - camX; const drawY = this.y - camY;
            ctx.fillStyle = "#111"; ctx.fillRect(drawX, drawY, this.w, this.h);
            ctx.fillStyle = "#fff"; ctx.fillRect(drawX, drawY, this.w, 2); 
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1; ctx.strokeRect(drawX, drawY, this.w, this.h);
        }
    }

    class PhasePlatform {
        constructor(x, y, w, h, offset) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.offset = offset; 
            this.active = true;
        }
        update() {
            let cycle = (frame + this.offset) % 180;
            if(cycle < 100) this.active = true;
            else this.active = false;
        }
        draw() {
            const drawX = this.x - camX; const drawY = this.y - camY;
            if(this.active) {
                ctx.fillStyle = "#fff"; 
                let shake = Math.random() < 0.1 ? (Math.random()-0.5)*4 : 0;
                ctx.fillRect(drawX + shake, drawY, this.w, this.h);
                ctx.shadowBlur = 10; ctx.shadowColor = "#fff";
                ctx.fillRect(drawX, drawY, this.w, 2); 
                ctx.shadowBlur = 0;
            } else {
                ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(drawX, drawY, this.w, this.h);
                ctx.setLineDash([]);
            }
        }
    }

    class Station {
        constructor(x, y) { this.x = x; this.y = y; this.w = 100; this.h = 150; }
        draw() {
            const drawX = this.x - camX; const drawY = this.y - camY;
            ctx.fillStyle = "#fff"; ctx.fillRect(drawX, drawY, this.w, this.h);
            if(Math.random() > 0.8) {
                ctx.fillStyle = "#000"; 
                ctx.fillRect(drawX + Math.random()*80, drawY + Math.random()*130, 20, 5);
            }
            ctx.fillStyle = "#000"; ctx.fillText("SOURCE", drawX + 25, drawY + 20);
        }
        checkWin(p) {
            if (p.x > this.x + 20 && p.x < this.x + 80 && p.y > this.y) {
                gameState = "WON";
                winEl.style.display = "block";
            }
        }
    }

    class Player {
        constructor() {
            this.x = PLAYER_START_X; this.y = 100; this.w = 22; this.h = 30; this.velX = 0; this.velY = 0;
            this.grounded = false; this.facingRight = true; this.animTimer = 0; this.idleTimer = 0; this.dead = false; this.coyoteTimer = 0;
        }
        update() {
            if(this.dead || gameState === "WON") return;
            
            let moving = false;
            if (keys.right) { if (this.velX < MAX_SPEED) this.velX += MOVE_SPEED; this.facingRight = true; moving = true; }
            if (keys.left) { if (this.velX > -MAX_SPEED) this.velX -= MOVE_SPEED; this.facingRight = false; moving = true; }
            
            this.idleTimer += 0.05;
            if (moving && this.grounded) this.animTimer += 0.2; else this.animTimer = 0;

            if(this.grounded) { this.velX *= GROUND_FRICTION; this.coyoteTimer = 6; } else { this.velX *= AIR_RESISTANCE; this.coyoteTimer--; }

            this.velY += GRAVITY; 
            this.x += this.velX; 

            if(this.x > distanceTraveled) distanceTraveled = this.x;

            // *** CHECKPOINT LOGIC ***
            if (distanceTraveled > nextCheckpointDist) {
                lastCheckpoint = { x: this.x, y: this.y - 10 };
                nextCheckpointDist += CHECKPOINT_INTERVAL;
                
                // Show UI
                checkEl.innerText = "DATA SAVED - " + Math.floor(distanceTraveled) + "m";
                checkEl.style.opacity = 1;
                Audio.save();
                setTimeout(() => { checkEl.style.opacity = 0; }, 3000);
            }

            this.grounded = false;
            
            for(let plat of platforms) {
                if (this.x < plat.x + plat.w && this.x + this.w > plat.x) {
                    if (this.y + this.h > plat.y && this.y + this.h < plat.y + this.velY + 20 && this.velY >= 0) {
                        this.y = plat.y - this.h; this.velY = 0; this.grounded = true;
                    }
                }
            }

            for(let plat of phasePlatforms) {
                if(plat.active) { 
                    if (this.x < plat.x + plat.w && this.x + this.w > plat.x) {
                        if (this.y + this.h > plat.y && this.y + this.h < plat.y + this.velY + 20 && this.velY >= 0) {
                            this.y = plat.y - this.h; this.velY = 0; this.grounded = true;
                        }
                    }
                }
            }

            for(let enemy of enemies) {
                if(Math.abs(this.x - enemy.x) < 20 && Math.abs(this.y - enemy.y) < 20) die();
            }

            if(station) station.checkWin(this);

            this.y += this.velY;
            if(this.y > canvas.height + 600) die(); 

            let targetX = this.x - canvas.width / 2; 
            camX += (targetX - camX) * 0.1;
            camY += ((this.y - 250) - camY) * 0.1;
        }
        draw() {
            if(this.dead) return;
            const drawX = this.x - camX; const drawY = this.y - camY;
            
            ctx.fillStyle = "#000000"; 
            ctx.strokeStyle = "#00ffff"; 
            
            let bobY = 0;
            if (!this.grounded) { bobY = -4; } 
            else if (Math.abs(this.velX) > 0.1) { bobY = Math.sin(this.animTimer * 2) * 1.5; } 
            else { bobY = Math.sin(this.idleTimer) * 0.5; }

            let swing = Math.sin(this.animTimer) * 12; 

            this.drawArm(drawX + 2, drawY + 10 + bobY, -swing);
            
            ctx.fillStyle = "#000000"; 
            ctx.fillRect(drawX + 6 + (swing*0.5), drawY + 28, 4, 14); ctx.strokeRect(drawX + 6 + (swing*0.5), drawY + 28, 4, 14);
            ctx.fillRect(drawX + 12 - (swing*0.5), drawY + 28, 4, 14); ctx.strokeRect(drawX + 12 - (swing*0.5), drawY + 28, 4, 14);

            ctx.fillRect(drawX, drawY + bobY, 22, 28); ctx.strokeRect(drawX, drawY + bobY, 22, 28);
            ctx.fillRect(drawX - 2, drawY - 14 + bobY, 26, 16); ctx.strokeRect(drawX - 2, drawY - 14 + bobY, 26, 16);
            
            let antWobble = Math.sin(frame * 0.05) * 0.5; if(Math.abs(this.velX)>1) antWobble = -this.velX;
            ctx.fillStyle = "#00ffff"; 
            ctx.fillRect(drawX + 10 + antWobble, drawY - 20 + bobY, 2, 6);

            this.drawArm(drawX + 18, drawY + 10 + bobY, swing);
            
            let eyeH = Math.abs(this.velX) > 1 ? 3 : 6; 
            ctx.shadowBlur = 10; ctx.shadowColor = "#00ffff"; ctx.fillStyle = "#00ffff";
            if(this.facingRight) ctx.fillRect(drawX + 18, drawY + 5 + bobY, 6, eyeH); 
            else ctx.fillRect(drawX + 2, drawY + 5 + bobY, 6, eyeH); 
            ctx.shadowBlur = 0;
        }
        drawArm(pivotX, pivotY, angleOffset) {
            let endX = pivotX; let endY = pivotY + 16;
            if(Math.abs(this.velX) > 0.5) { endX = pivotX + angleOffset; endY = pivotY + 14 - Math.abs(angleOffset * 0.2); }
            ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = "#00ffff"; 
            ctx.moveTo(pivotX, pivotY); ctx.lineTo(endX, endY); ctx.stroke();
            ctx.fillStyle = "#000"; ctx.fillRect(endX - 3, endY - 2, 6, 6); ctx.strokeRect(endX - 3, endY - 2, 6, 6);
        }
    }

    class Drone {
        constructor(x, y) {
            this.x = x; this.y = y; this.w = 20; this.h = 20; this.startX = x;
        }
        update() {
            if(Math.random() > 0.95) {
                this.x = this.startX + (Math.random()-0.5) * 100;
            }
        }
        draw() {
            const drawX = this.x - camX; const drawY = this.y - camY;
            ctx.fillStyle = "#fff"; 
            ctx.beginPath(); ctx.moveTo(drawX, drawY); ctx.lineTo(drawX+20, drawY); ctx.lineTo(drawX+10, drawY+20); ctx.fill();
            if(Math.random() > 0.8) ctx.fillRect(drawX + Math.random()*20, drawY, 5, 5);
        }
    }

    class Pulse {
        constructor(x, y) { this.x = x; this.y = y; this.radius = 1; this.alpha = 1; this.active = true; Audio.pulse(); }
        update() { 
            this.radius += 10; this.alpha -= 0.05; if(this.alpha <= 0) this.active = false; 
            enemies.forEach((e, i) => { 
                let dx = this.x - e.x; let dy = this.y - e.y;
                if(Math.sqrt(dx*dx + dy*dy) < this.radius) { enemies.splice(i, 1); Audio.crash(); }
            });
        }
        draw() {
            const drawX = this.x - camX; const drawY = this.y - camY;
            ctx.beginPath(); ctx.arc(drawX, drawY, this.radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`; ctx.lineWidth = 4; ctx.stroke();
        }
    }

    class Debris {
        constructor(x, y) { 
            this.x = x; this.y = y; this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10; this.life = 1.0; 
            this.color = Math.random() > 0.5 ? "#00ffff" : "#ffffff";
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
        draw() { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.fillRect(this.x-camX, this.y-camY, 4,4); ctx.globalAlpha=1; }
    }

    function fireLaser() {
        Audio.laser();
        let dir = player.facingRight ? 1 : -1;
        bullets.push({ x: player.x + (dir * 20), y: player.y + 10, vx: dir * 15, life: 60 });
    }

    function createPulse() { pulses.push(new Pulse(player.x + 10, player.y + 15)); }

    function die() {
        if(player.dead) return;
        player.dead = true; Audio.crash();
        for(let i=0; i<30; i++) debris.push(new Debris(player.x, player.y));
        setTimeout(() => {
            player.x = lastCheckpoint.x; player.y = 200; 
            player.velX = 0; player.velY = 0;
            camX = player.x - 400;
            player.dead = false;
            resetLevelAt(player.x);
        }, 1000);
    }

    let platforms = []; let phasePlatforms = []; let enemies = []; let bullets = []; let debris = []; let pulses = [];
    let nextPlatformX = -100; let station = null;
    let bgStatic = []; 
    for(let i=0; i<100; i++) bgStatic.push({x: Math.random()*800, y: Math.random()*450, w: Math.random()*20, h: 2});

    function resetLevelAt(startX) {
        platforms = []; phasePlatforms = []; enemies = []; bullets = []; debris = [];
        platforms.push(new Platform(startX - 500, 350, 1000, 50));
        camX = startX - 400; 
        nextPlatformX = startX + 600;
        
        // Recalculate next checkpoint so it doesn't trigger immediately
        nextCheckpointDist = Math.ceil(startX / CHECKPOINT_INTERVAL) * CHECKPOINT_INTERVAL + CHECKPOINT_INTERVAL;
    }

    function generateTerrain() {
        if(nextPlatformX > WIN_DIST + 1000) return;
        
        while(nextPlatformX < camX + canvas.width + 1000) {
            
            if(nextPlatformX > WIN_DIST && !station) {
                platforms.push(new Platform(nextPlatformX, 350, 1000, 50));
                station = new Station(nextPlatformX + 800, 200);
                nextPlatformX += 2000;
                return;
            }

            // PATTERN: Phasing Bridges
            if (Math.random() < 0.6) {
                let w = 200;
                phasePlatforms.push(new PhasePlatform(nextPlatformX, 350, w, 20, Math.random()*180));
                if(Math.random() < 0.4) enemies.push(new Drone(nextPlatformX + w/2, 250));
                nextPlatformX += w + 100;
            } 
            else {
                let w = 150;
                platforms.push(new Platform(nextPlatformX, 350, w, 50));
                nextPlatformX += w + 100;
            }
        }
        if(platforms.length > 0 && platforms[0].x < camX - 1000) platforms.shift();
    }

    const player = new Player();
    resetLevelAt(100);

    function loop() {
        scoreEl.innerText = Math.floor(distanceTraveled) + "m / " + WIN_DIST + "m";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        generateTerrain();

        ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
        bgStatic.forEach(s => {
            if(Math.random() > 0.5) ctx.fillRect(s.x, s.y, s.w, s.h);
        });

        ctx.save();
        ctx.translate(0, 0); 
        
        if(station) station.draw();
        platforms.forEach(p => p.draw());
        phasePlatforms.forEach(p => { p.update(); p.draw(); });
        enemies.forEach(e => { e.update(); e.draw(); });
        
        ctx.fillStyle = "cyan";
        for(let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; b.x += b.vx; b.life--;
            ctx.fillRect(b.x - camX, b.y - camY, 15, 4);
            if(b.life <= 0) bullets.splice(i, 1);
        }

        player.update(); player.draw();
        
        pulses.forEach((p,i) => { p.update(); p.draw(); if(!p.active) pulses.splice(i,1); });
        debris.forEach((d,i) => { d.update(); d.draw(); if(d.life<=0) debris.splice(i,1); });

        ctx.restore();
        frame++; requestAnimationFrame(loop);
    }
    loop();

</script>
</body>
</html>